/* Generated by Streams Studio: March 21, 2014 5:31:03 PM PDT */
package com.ibm.streamsx.log4j;


import java.io.File;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.net.Socket;

import org.apache.log4j.Hierarchy;
import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import org.apache.log4j.Priority;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.net.SocketNode;
import org.apache.log4j.spi.LoggerRepository;
import org.apache.log4j.spi.RootLogger;

import com.ibm.streams.operator.OperatorContext;
import com.ibm.streams.operator.OutputTuple;
import com.ibm.streams.operator.StreamingOutput;
import com.ibm.streams.operator.metrics.Metric;
import com.ibm.streams.operator.metrics.Metric.Kind;
import com.ibm.streams.operator.model.CustomMetric;
import com.ibm.streams.operator.model.OutputPortSet;
import com.ibm.streams.operator.model.OutputPortSet.WindowPunctuationOutputMode;
import com.ibm.streams.operator.model.OutputPorts;
import com.ibm.streams.operator.model.Parameter;
import com.ibm.streams.operator.model.PrimitiveOperator;
import com.ibm.streams.operator.samples.patterns.TupleProducer;

/**
 * A source operator that does not receive any input streams and produces new tuples. 
 * The method <code>produceTuples</code> is called to begin submitting tuples.
 * <P>
 * For a source operator, the following event methods from the Operator interface can be called:
 * </p>
 * <ul>
 * <li><code>initialize()</code> to perform operator initialization</li>
 * <li>allPortsReady() notification indicates the operator's ports are ready to process and submit tuples</li> 
 * <li>shutdown() to shutdown the operator. A shutdown request may occur at any time, 
 * such as a request to stop a PE or cancel a job. 
 * Thus the shutdown() may occur while the operator is processing tuples, punctuation marks, 
 * or even during port ready notification.</li>
 * </ul>
 * <p>With the exception of operator initialization, all the other events may occur concurrently with each other, 
 * which lead to these methods being called concurrently by different threads.</p> 
 */
@PrimitiveOperator(name="ReceiveLog4j", namespace="com.ibm.streamsx.log4j",
description="Java Operator ReceiveLog4j")
@OutputPorts({@OutputPortSet(description="Port that produces tuples", cardinality=1, optional=false, windowPunctuationOutputMode=WindowPunctuationOutputMode.Generating), @OutputPortSet(description="Optional output ports", optional=true, windowPunctuationOutputMode=WindowPunctuationOutputMode.Generating)})
public class ReceiveLog4j extends TupleProducer {
	private Metric nConnectedLoggers;
	private Metric nLoggedMessages;
	private Socket currentSocket;

	@CustomMetric(description="Number of logging clients connected.", kind=Kind.GAUGE)
	public void setnConnectedLoggers(Metric nConnectedLoggers) {
		this.nConnectedLoggers = nConnectedLoggers;
	}
	public Metric getnConnectedLoggers() {
		return this.nConnectedLoggers;
	}
	public void clientDisconnect(Socket socket) {
        nConnectedLoggers.incrementValue((long)-1);
		Logger.getLogger(this.getClass()).trace(" Client disconnected : " + socket.getInetAddress());
	}

	@CustomMetric(description="Number of messages logged.", kind=Kind.COUNTER)
	public void setnLoggedMessages(Metric nLoggedMessages) {
		this.nLoggedMessages = nLoggedMessages;
	}
	public Metric getnLoggedMessages() {
		return this.nLoggedMessages;
	}

	/**
	 * Thread for calling <code>produceTuples()</code> to produce tuples 
	 */
    private Thread processThread;
	LoggerRepository streamsRepository = null;
	LoggerRepository getRepository() {
		if (streamsRepository == null) {
			File f = new File(getLog4jConfig());
			if (!f.exists()) {
				throw new IllegalArgumentException("Configuration file not found : " + getLog4jConfig());
			}
  			streamsRepository = new Hierarchy(new RootLogger((Level)Priority.DEBUG));
			new PropertyConfigurator().doConfigure(f.getAbsolutePath(), streamsRepository);

		}
		return streamsRepository;
	}
	void setCurrentSocket(Socket socket) {
		currentSocket = socket;
	}
	public Socket getCurrentSocket() {
		return currentSocket;
	}

    /**
     * Initialize this operator. Called once before any tuples are processed.
     * @param context OperatorContext for this operator.
     * @throws Exception Operator failure, will cause the enclosing PE to terminate.
     */
    @Override
    public synchronized void initialize(OperatorContext context)
            throws Exception {
    	// Must call super.initialize(context) to correctly setup an operator.
		new StreamsAppenderInitialize(this);			    	
        super.initialize(context);
        //new StreamsAppenderInitialize(this);
        Logger.getLogger(this.getClass()).trace("Operator " + context.getName() + " initializing in PE: " + context.getPE().getPEId() + " in Job: " + context.getPE().getJobId() );
        
        // TODO:

        /*
         * Create the thread for producing tuples. 
         * The thread is created at initialize time but started.
         * The thread will be started by allPortsReady().
         */

        processThread = getOperatorContext().getThreadFactory().newThread(
                new Runnable() {
                    @Override
                	public final void run() {
                        OperatorContext context = getOperatorContext();
            			try {
            		        Logger.getLogger(this.getClass()).trace("Operator " + context.getName() + " all ports are ready in PE: " + context.getPE().getPEId() + " in Job: " + context.getPE().getJobId() );
            		        Logger.getLogger(this.getClass()).trace("Opening port '" +portNum + "' to receive log4j messages.");
            				ServerSocket serverSocket = new ServerSocket(portNum);
            					while(true) {
            		        		Logger.getLogger(this.getClass()).trace("Operator " + context.getName() + " Waiting for connections on '" +portNum + "'");
            							Socket socket  = serverSocket.accept();
            							setCurrentSocket(socket);
            							InetAddress inetAddress = socket.getInetAddress();            							
                		        		Logger.getLogger(this.getClass()).trace("Operator " + context.getName() + " Connections to '" +inetAddress + "' established.");            						            							
                        		        nConnectedLoggers.increment();
            							//LoggerRepository h = LogManager.getLoggerRepository();
            							LoggerRepository h = getRepository();
            							new Thread(new SocketNode(socket,h)).start();
            					}
            			} catch (Exception e) {
            		        Logger.getLogger(this.getClass()).error("Operator " + context.getName() + " opening port '" +portNum + "' : " +  e.getMessage());            				            		        
            				e.printStackTrace();
            			}
                    }                    

                });
        
        /*
         * Set the thread not to be a daemon to ensure that the SPL runtime
         * will wait for the thread to complete before determining the
         * operator is complete.
         */
        processThread.setDaemon(false);
    }

    int portNum;
@Parameter(name="port", optional=false, description="TCP log4j recieve port")
	public void setPort(int portNum) {
		this.portNum = portNum;
	}
	public int getPort() {
		return this.portNum;
	}

String log4jConfig;
@Parameter(name="log4jConfig", optional=true, description="log4j configuration file")
	public void setLog4jConfig(String log4jConfig) {
		this.log4jConfig = log4jConfig;
	}
	public String getLog4jConfig(){
        Logger.getLogger(this.getClass()).info("Log4j configuration file : " + this.log4jConfig);		
		return this.log4jConfig;
	}

    /**
     * Notification that initialization is complete and all input and output ports 
     * are connected and ready to receive and submit tuples.
     * @throws Exception Operator failure, will cause the enclosing PE to terminate.
     */
    @Override
    public synchronized void allPortsReady() throws Exception {
        OperatorContext context = getOperatorContext();
        Logger.getLogger(this.getClass()).trace("Operator " + context.getName() + " all ports are ready in PE: " + context.getPE().getPEId() + " in Job: " + context.getPE().getJobId() );
    	// Start a thread for producing tuples because operator 
    	// implementations must not block and must return control to the caller.
        processThread.start();
    }
    
    /**
     * Submit new tuples to the output stream
     * @throws Exception if an error occurs while submitting a tuple
     */
    public void produceTuples(String loggingMessage) throws Exception  {
        OperatorContext context = getOperatorContext();    	
        final StreamingOutput<OutputTuple> out = getOutput(0);
        nLoggedMessages.increment();
        Logger.getLogger(this.getClass()).debug("Operator " + context.getName() + "log4j :" + loggingMessage );        
        OutputTuple tuple = out.newTuple();         // gen tuple
        tuple.setString("message", loggingMessage); // load tuple
        out.submit(tuple);							// submit 
    }

    /**
     * Shutdown this operator, which will interrupt the thread
     * executing the <code>produceTuples()</code> method.
     * @throws Exception Operator failure, will cause the enclosing PE to terminate.
     */
    public synchronized void shutdown() throws Exception {
        if (processThread != null) {
            processThread.interrupt();
            processThread = null;
        }
        System.out.println("shutdown");
        OperatorContext context = getOperatorContext();
        Logger.getLogger(this.getClass()).trace("Operator " + context.getName() + " shutting down in PE: " + context.getPE().getPEId() + " in Job: " + context.getPE().getJobId() );
        
        // TODO: If needed, close connections or release resources related to any external system or data store.

        // Must call super.shutdown()
        super.shutdown();
    }

	@Override
	protected void startProcessing() throws Exception {
		// TODO Auto-generated method stub
		
	}
}
